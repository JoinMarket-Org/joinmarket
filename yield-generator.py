#! /usr/bin/env python

import time, os, binascii, sys, datetime
import pprint
data_dir = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, os.path.join(data_dir, 'lib'))

from maker import *
from irc import IRCMessageChannel, random_nick
import bitcoin as btc
import common, blockchaininterface

from socket import gethostname
import random
mix_levels = 5

#CONFIGURATION
nickname = random_nick()
nickserv_password = ''

#num_offers: number of offers to generate when cjfee and my_offer_levels are being autogenerated (default)
#txfee: miner fee contribution in satoshis
#cjfee: fee for mix levels from min to max. 0.01 is 1%
#min_cjfee: how much profit you require your orders to get per transaction
#min_order_size and max_order_size are in satoshis
#min_output_size: only create change greater than this amount
#Choose one of each below

num_offers = 5

txfee = random.randrange(300, 3000) #random
#txfee = 2000

cjfee = sorted(["%0.6f" % float(random.uniform(0.00001, 0.0001)) for n in range(num_offers)]) #random
#cjfee = ['0.000010', '0.000020', '0.000030', '0.000070', '0.000100']
#cjfee = ["%0.5f" % (0.00011 + n*0.00001) for n in range(num_offers)]

my_offer_levels = None #will be autogenerated
#my_offer_levels = [100000000, 1000000000, 2000000000, 3000000000, 4000000000]

min_cjfee = random.randrange(txfee, txfee * 5) #random
#min_cjfee = int(1.5 * txfee) # 50% net revenue
#min_cjfee = 3000

min_output_size = 3000
#min_output_size = common.DUST_THRESHOLD # 546 satoshis

min_order_size = random.randrange(min_output_size, 500000) #random
#min_order_size = min_output_size
#min_order_size = 500000

#This is useful when using autogenerated offer levels
max_order_size = 2100000000000000 #21 mil btc, highest max (off)
#max_order_size = 5000000000 #50 btc
#max_order_size = random.randrange(2500000000, 10000000000) #random, between 25 and 100 btc

#END CONFIGURATION

print "txfee = " + str(txfee)
print "min_cjfee = " + str(min_cjfee)
print "cjfee = " + str(cjfee)
print "offer_levels = " + str(my_offer_levels)
print "min_output_size = " + str(min_output_size)
print "min_order_size = " + str(min_order_size)
print "max_order_size = " + str(max_order_size)

#is a maker for the purposes of generating a yield from held
# bitcoins without ruining privacy for the taker, the taker could easily check
# the history of the utxos this bot sends, so theres not much incentive
# to ruin the privacy for barely any more yield
#sell-side algorithm:
#add up the value of each utxo for each mixing depth,
# amounts made to be non-overlapping
# minsize set by the miner fee contribution, so you never earn less in cjfee than miner fee
class YieldGenerator(Maker):
	statement_file = os.path.join('logs', 'yigen-statement.csv')

	def __init__(self, msgchan, wallet):
		Maker.__init__(self, msgchan, wallet)
		self.msgchan.register_channel_callbacks(self.on_welcome, self.on_set_topic,
			None, None, self.on_nick_leave, None)
		self.tx_unconfirm_timestamp = {}

	def log_statement(self, data):
		if common.get_network() == 'testnet':
			return

		data = [str(d) for d in data]
		self.income_statement = open(self.statement_file, 'a')
		self.income_statement.write(','.join(data) + '\n')
		self.income_statement.close()

	def on_welcome(self):
		Maker.on_welcome(self)
		if not os.path.isfile(self.statement_file):
			self.log_statement(['timestamp', 'cj amount/satoshi', 'my input count',
				'my input value/satoshi', 'cjfee/satoshi', 'earned/satoshi',
				'confirm time/min', 'notes'])

		timestamp = datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")
		self.log_statement([timestamp, '', '', '', '', '', '', 'Connected'])

	def create_my_orders(self):
		mix_balance = self.wallet.get_balance_by_mixdepth()
		debug('mix_balance = ' + str(mix_balance))
		nondust_mix_balance = dict([(m, b) for m, b in mix_balance.iteritems() if b > min_output_size])
		if len(nondust_mix_balance) == 0:
			debug('do not have any coins left')
			return []
		mix_balance = sorted(list(mix_balance.iteritems()), key=lambda a: a[1]) #sort by size

                #randomly generate order levels
                largest_offer = min(mix_balance[-1][1] - min_output_size, max_order_size)
                if not my_offer_levels:
                    offer_levels = sorted([random.randrange(min_order_size + 1, largest_offer) for n in range(num_offers)])
                else:
                    offer_levels = my_offer_levels
		debug('offer_levels = ' + str(offer_levels))
                lower_bound_balances = [min_order_size] + [x + 1 for x in offer_levels[:-1]]
		mix_balance_min = zip(offer_levels, lower_bound_balances, cjfee)
		debug('mixdepth_balance_min = ' + str(mix_balance_min))
		orders=[]
		oid = 0
		for mix_bal_min in mix_balance_min:
                    upper, lower, fee = mix_bal_min
                    #the maker class reads specific keys from the dict, but others
                    # are allowed in there and will be ignored
		    upper = max(upper, min_output_size)
                    lower = max(lower, min_output_size, min_order_size)
		    if float(fee) > 0:
		    	min_needed = int(min_cjfee / float(fee))
		    else:
			min_needed = min_cjfee
		    if min_needed <= lower:
                        #create a regular relorder
                        order = {'oid': oid, 'ordertype': 'relorder', 'minsize': lower,
                                'maxsize': upper, 'txfee': txfee, 'cjfee': fee}
                        oid += 1
                        orders.append(order)
		    elif min_needed > lower and min_needed < upper:
                        #create two orders. An absolute for lower bound need, and relorder for rest
                        order = {'oid': oid, 'ordertype': 'absorder', 'minsize': lower,
                                'maxsize': min_needed - 1, 'txfee': txfee, 'cjfee': min_cjfee}
                        oid += 1
                        orders.append(order)
                        order = {'oid': oid, 'ordertype': 'relorder', 'minsize': min_needed,
                                'maxsize': upper, 'txfee': txfee, 'cjfee': fee}
                        oid += 1
                        orders.append(order)
		    elif min_needed >= upper:
                        #just create a single absolute order
                        order = {'oid': oid, 'ordertype': 'absorder', 'minsize': lower,
                                'maxsize': upper, 'txfee': txfee, 'cjfee': min_cjfee}
                        oid += 1
                        orders.append(order)

		debug('generated orders = \n' + '\n'.join([str(o) for o in orders]))
		return orders

        def oid_to_order(self, cjorder, oid, amount):
                mix_balance = self.wallet.get_balance_by_mixdepth()
                #sort smallest to largest amount
                filtered_mix_balance = sorted(list(mix_balance.iteritems()), key= lambda x: x[1]) 
                #remove mix depths that do not have enough
                filtered_mix_balance = [m for m in mix_balance.iteritems() if m[1] >= amount] 

                #when we have more then one usable mix depth, and the max mix depth is one of them
                #then remove it so that coins keep moving down the mix depths
                if len(filtered_mix_balance) > 1 and self.wallet.max_mix_depth in [x[0] for x in filtered_mix_balance]:
                    filtered_mix_balance = [x for x in filtered_mix_balance if x[0] != self.wallet.max_mix_depth]

                mixdepth = filtered_mix_balance[0][0] #use smallest amount mixdepth that has enough coins
                #mixdepth = random.choice(filtered_mix_balance)[0] #random usable mixdepth

                debug('filling order, mixdepth=' + str(mixdepth))

                #mixdepth is the chosen depth we'll be spending from
                cj_addr = self.wallet.get_receive_addr((mixdepth + 1) % self.wallet.max_mix_depth)
                change_addr = self.wallet.get_change_addr(mixdepth)

                utxos = self.wallet.select_utxos(mixdepth, amount)
                my_total_in = sum([va['value'] for va in utxos.values()])
                real_cjfee = calc_cj_fee(cjorder.ordertype, cjorder.cjfee, amount)
                change_value = my_total_in - amount - cjorder.txfee + real_cjfee
                if change_value <= min_output_size:
                        debug('change value=%d below dust threshold, finding new utxos' % (change_value))
                        try:
                                utxos = self.wallet.select_utxos(mixdepth, amount + min_output_size)
                        except Exception:
                                debug('dont have the required UTXOs to make a output above the dust threshold, quitting')
                                return None, None, None

                return utxos, cj_addr, change_addr

	def on_tx_unconfirmed(self, cjorder, txid, removed_utxos):
		self.tx_unconfirm_timestamp[cjorder.cj_addr] = int(time.time())

		'''
		case 0
		the absorder will basically never get changed, unless there are no utxos left, when neworders==[]
		case 1
		a single coin is split into two coins across levels
		must announce a new order, plus modify the old order
		case 2
		two existing mixdepths get modified
		announce the modified new orders
		case 3
		one existing mixdepth gets emptied into another
		cancel it, modify the place it went

		algorithm
		find all the orders which have changed, the length of that list tells us which case
		'''

		myorders = self.create_my_orders()
		oldorders = self.orderlist
		if len(myorders) == 0:
			return ([o['oid'] for o in oldorders], [])

		cancel_orders = []
		ann_orders = []

		neworders = [o for o in myorders if o['ordertype'] == 'relorder']
		oldorders = [o for o in oldorders if o['ordertype'] == 'relorder']
		#new_setdiff_old = The relative complement of `new` in `old` = members in `new` which are not in `old`
		new_setdiff_old = [o for o in neworders if o not in oldorders]
		old_setdiff_new = [o for o in oldorders if o not in neworders]

		debug('neworders = \n' + '\n'.join([str(o) for o in neworders]))
		debug('oldorders = \n' + '\n'.join([str(o) for o in oldorders]))
		debug('new_setdiff_old = \n' + '\n'.join([str(o) for o in new_setdiff_old]))
		debug('old_setdiff_new = \n' + '\n'.join([str(o) for o in old_setdiff_new]))
		if len(neworders) == len(oldorders):
			ann_orders = new_setdiff_old
		elif len(neworders) > len(oldorders):
			ann_orders = new_setdiff_old
		elif len(neworders) < len(oldorders):
			ann_orders = new_setdiff_old
			ann_oids = [o['oid'] for o in ann_orders]
			cancel_orders = [o['oid'] for o in old_setdiff_new if o['oid'] not in ann_oids]

		#check if the absorder has changed, or if it needs to be newly announced
		new_abs = [o for o in myorders if o['ordertype'] == 'absorder']
		old_abs = [o for o in oldorders if o['ordertype'] == 'absorder']
		if len(new_abs) > len(old_abs):
			#announce an absorder where there wasnt one before
			ann_orders = [new_abs[0]] + ann_orders
		elif len(new_abs) == len(old_abs) and len(old_abs) > 0:
			#maxsize is the only thing that changes, except cjfee but that changes at the same time
			if new_abs[0]['maxsize'] != old_abs[0]['maxsize']:
				ann_orders = [new_abs[0]] + ann_orders

		debug('can_orders = \n' + '\n'.join([str(o) for o in cancel_orders]))
		debug('ann_orders = \n' + '\n'.join([str(o) for o in ann_orders]))
		return (cancel_orders, ann_orders)

	def on_tx_confirmed(self, cjorder, confirmations, txid):
		if cjorder.cj_addr in self.tx_unconfirm_timestamp:
			confirm_time = int(time.time()) - self.tx_unconfirm_timestamp[cjorder.cj_addr]
		else:
			confirm_time = 0
		del self.tx_unconfirm_timestamp[cjorder.cj_addr]
		timestamp = datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")
		self.log_statement([timestamp, cjorder.cj_amount, len(cjorder.utxos),
			sum([av['value'] for av in cjorder.utxos.values()]), cjorder.real_cjfee,
			cjorder.real_cjfee - cjorder.txfee, round(confirm_time / 60.0, 2), ''])
		return self.on_tx_unconfirmed(cjorder, txid, None)

def main():
	common.load_program_config()
	import sys
	seed = sys.argv[1]
	if isinstance(common.bc_interface, blockchaininterface.BlockrInterface):
		print '\nYou are running a yield generator by polling the blockr.io website'
		print 'This is quite bad for privacy. That site is owned by coinbase.com'
                print 'Also your bot will run faster and more efficently, you can be immediately notified of new bitcoin network'
		print ' information so your money will be working for you as hard as possible'
		print 'Learn how to setup JoinMarket with Bitcoin Core: https://github.com/chris-belcher/joinmarket/wiki/Running-JoinMarket-with-Bitcoin-Core-full-node'
		ret = raw_input('\nContinue? (y/n):')
		if ret[0] != 'y':
			return

	wallet = Wallet(seed, max_mix_depth = mix_levels)
	common.bc_interface.sync_wallet(wallet)
	
	common.nickname = nickname
	debug('starting yield generator')
	irc = IRCMessageChannel(common.nickname, realname='btcint=' + common.config.get("BLOCKCHAIN", "blockchain_source"),
		password=nickserv_password)
	maker = YieldGenerator(irc, wallet)
	try:
		debug('connecting to irc')
		irc.run()
	except:
		debug('CRASHING, DUMPING EVERYTHING')
		debug_dump_object(wallet, ['addr_cache', 'keys', 'seed'])
		debug_dump_object(maker)
		debug_dump_object(irc)
		import traceback
		debug(traceback.format_exc())

if __name__ == "__main__":
	main()
	print('done')
